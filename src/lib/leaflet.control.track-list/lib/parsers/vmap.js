import {decode as uft8decode} from 'utf8';

import stripBom from '~/lib/stripBom';

// number read/skip, color, weight, name
const TypeTab = [
    [0x0700, 1, 0x009000, 6, 'город'],
    [0x0800, 1, 0x000000, 6, 'крупная деревня'],
    [0x0900, 1, 0x000000, 6, 'деревня'],
    [0x0f00, 1, 0x000000, 6, 'тригопункт'],
    [0x1100, 1, 0x000000, 6, 'отметка высоты'],
    [0x0d00, 1, 0x000000, 6, 'маленькая отметка высоты'],
    [0x1000, 1, 0x000000, 6, 'отметка уреза воды'],
    [0x2e00, 1, 0x000000, 6, 'магазин'],
    [0x2800, 1, 0x000000, 6, 'подпись лесного квартала, урочища'],
    [0x2c04, 1, 0x000000, 6, 'памятник'],
    [0x2c0b, 1, 0x000000, 6, 'церковь'],
    [0x2f08, 1, 0x000000, 6, 'остановка автобуса'],
    [0x5905, 1, 0x000000, 6, 'ж/д станция'],
    [0x6406, 0, 0x000000, 6, 'перевал неизвестной сложности'],
    [0x6700, 0, 0x000000, 6, 'перевал н/к'],
    [0x6701, 0, 0x000000, 6, 'перевал 1А'],
    [0x6702, 0, 0x000000, 6, 'перевал 1Б'],
    [0x6703, 0, 0x000000, 6, 'перевал 2А'],
    [0x6704, 0, 0x000000, 6, 'перевал 2Б'],
    [0x6705, 0, 0x000000, 6, 'перевал 3А'],
    [0x6706, 0, 0x000000, 6, 'перевал 3Б'],
    [0x660b, 1, 0x000000, 6, 'каньон'],
    [0x650a, 1, 0x000000, 6, 'ледопад'],
    [0x650b, 1, 0x000000, 6, 'номер ледника'],
    [0x650c, 1, 0x000000, 6, 'название ледника'],
    [0x6402, 1, 0x000000, 6, 'дом'],
    [0x6403, 1, 0x000000, 6, 'кладбище'],
    [0x6411, 1, 0x000000, 6, 'башня'],
    [0x6414, 1, 0x000000, 6, 'родник'],
    [0x6415, 1, 0x000000, 6, 'развалины'],
    [0x640c, 1, 0x000000, 6, 'шахты'],
    [0x6508, 1, 0x000000, 6, 'водопад'],
    [0x650e, 0, 0x000000, 6, 'порог /не использовать!/'],
    [0x6601, 1, 0x000000, 6, 'пещера'],
    [0x6603, 1, 0x000000, 6, 'яма'],
    [0x6606, 1, 0x000000, 6, 'охотничья вышка, кормушка и т.п.'],
    [0x6613, 1, 0x000000, 6, 'курган'],
    [0x6616, 1, 0x000000, 6, 'скала-останец'],
    [0x2b03, 1, 0x000000, 6, 'место стоянки'],
    [0x660a, 1, 0x000000, 6, 'одиночное дерево, внемасштабный лес'],

    [0x200016, 1, 0x009000, 6, 'лес'],
    [0x200052, 1, 0x00d000, 6, 'поле'],
    [0x200015, 1, 0x00b000, 6, 'остров леса'],
    [0x20004f, 1, 0x000000, 6, 'свежая вырубка'],
    [0x200050, 1, 0x000000, 6, 'стар.вырубка'],
    [0x200014, 1, 0x00a000, 6, 'редколесье'],

    [0x200004, 1, 0x803000, 6, 'закрытые территории'],
    [0x20000e, 1, 0xd000d0, 6, 'деревни'],
    [0x200001, 1, 0x900090, 6, 'города'],
    [0x20004e, 1, 0x006000, 6, 'дачи'],
    [0x20001a, 1, 0x004000, 6, 'кладбище'],

    [0x200029, 1, 0x0000ff, 4, 'водоемы'],
    [0x20003b, 1, 0x0000ff, 8, 'крупные водоемы'],
    [0x200053, 1, 0x0080ff, 4, 'остров'],
    [0x200051, 1, 0x000000, 6, 'заболоченность'],
    [0x20004c, 1, 0x000000, 6, 'болото'],
    [0x20004d, 1, 0x00ffff, 6, 'ледник'],
    [0x200019, 0, 0x000000, 6, 'крутой склон'],
    [0x20000a, 0, 0x000000, 6, 'дырка в srtm-данных'],
    [0x200008, 1, 0x000000, 6, 'осыпь'],
    [0x20000d, 1, 0x000000, 6, 'песок'],

    [0x100000, 0, 0x000000, 6, 'кривая надпись'],
    [0x100005, 0, 0x000000, 6, 'отдельные строения'],

    [0x100016, 1, 0x000000, 6, 'просека'],
    [0x10001c, 0, 0x000000, 6, 'просека широкая'],
    [0x10002d, 1, 0x000000, 6, 'заросшая дорога'],
    [0x10002e, 0, 0x000000, 6, 'заросшая заметная дорога (знак ММБ)'],
    [0x10002a, 1, 0xff0000, 2, 'тропа'],
    [0x10000a, 1, 0xff0000, 4, 'непроезжая грунтовка'],
    [0x100006, 1, 0xff0080, 4, 'проезжая грунтовка'],
    [0x100004, 1, 0xff00ff, 4, 'проезжий грейдер'],
    [0x100007, 0, 0x000000, 6, 'непроезжий грейдер'],
    [0x100002, 1, 0xd00000, 6, 'шоссе'],
    [0x10000b, 1, 0xd00000, 8, 'большое шоссе'],
    [0x100001, 1, 0xd00000, 10, 'автомагистраль'],
    [0x10000d, 1, 0x006080, 6, 'УЖД'],
    [0x100027, 1, 0x006080, 8, 'железная дорога'],

    [0x100008, 1, 0xff8000, 2, 'мост-1 (пешеходный)'],
    [0x100009, 1, 0xff8000, 4, 'мост-2 (автомобильный)'],
    [0x10000e, 1, 0xff8000, 6, 'мост-5 (на автомагистралях)'],
    [0x10001b, 1, 0x00ffd0, 4, 'пешеходный тоннель'],

    [0x10001a, 1, 0x808080, 4, 'маленькая ЛЭП'],
    [0x100029, 1, 0x808080, 8, 'ЛЭП'],
    [0x100028, 1, 0x808040, 8, 'газопровод'],
    [0x100019, 1, 0xff4040, 2, 'забор'],

    [0x10002b, 1, 0xa06010, 4, 'сухая канава'],
    [0x100003, 1, 0xf04040, 2, 'верхний край обрыва'],
    [0x10001e, 0, 0x000000, 6, 'нижний край обрыва'],
    [0x10000f, 0, 0x000000, 6, 'малый хребет'],
    [0x10000c, 1, 0xd06000, 6, 'хребет'],
    [0x100020, 0, 0x000000, 6, 'пунктирная горизонталь'],
    [0x100021, 0, 0x000000, 6, 'горизонтали, бергштрихи'],
    [0x100022, 0, 0x000000, 6, 'жирная горизонталь'],
    [0x100025, 1, 0x000000, 6, 'овраг'],
    [0x10002c, 1, 0x000000, 6, 'вал'],

    [0x100026, 1, 0x0080ff, 2, 'пересыхающий ручей'],
    [0x100015, 1, 0x0000ff, 4, 'река-1'],
    [0x100018, 1, 0x0000d0, 6, 'река-2'],
    [0x10001f, 1, 0x000080, 8, 'река-3'],

    [0x10001d, 1, 0xe080ff, 8, 'граница стран, областей'],
    [0x100036, 1, 0xe080ff, 6, 'граница областей, районов'],
    [0x100037, 1, 0xe9ac36, 6, 'граница заповедников, парков'],

    [0x100023, 0, 0x000000, 6, 'контур леса'],
    [0x100024, 0, 0x000000, 6, 'болото'],

    [0x100032, 0, 0x000000, 6, 'плохой путь'],
    [0x100033, 0, 0x000000, 6, 'удовлетворительный путь'],
    [0x100034, 0, 0x000000, 6, 'хороший путь'],
    [0x100035, 0, 0x000000, 6, 'отличный путь'],

    [0x100050, 0, 0x000000, 6, 'bad route /не использовать!/'],
    [0x10007f, 0, 0x000000, 6, 'text object'],
    [0x10007e, 0, 0x000000, 6, 'border object'],
];

function parseVMAP1(txt, _unused_name) {
    let error;
    let type = 0;
    const types = {};

    const skip = {};
    for (const tt of TypeTab) {
        if (tt[1] === 0) {
            skip[tt[0]] = 1;
        }
    }

    const lines = stripBom(txt).split('\n');
    if (lines[0].indexOf('VMAP') !== 0) {
        return null;
    }
    for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (!line) {
            continue;
        }

        const pos1 = line.search('\t');
        if (pos1 === -1) {
            continue;
        }
        const key = line.slice(0, pos1).trim();
        const val = line.slice(pos1 + 1).trim();

        if (key === 'OBJECT') {
            let n = '';
            type = val;
            const pos2 = val.search(' ');
            if (pos2 !== -1) {
                type = val.slice(0, pos2);
                n = uft8decode(val.slice(pos2 + 1));
            }
            type = parseInt(type, 16);

            if (skip[type]) {
                type = '';
                continue;
            }

            if (!types[type]) {
                types[type] = [];
            }
            types[type].push({name: n, crd: [], lab: [], opt: []});
            continue;
        }

        // only fields related to an object:
        if (key !== 'DATA' && key !== 'LABEL' && key !== 'OPT' && key !== '') {
            continue;
        }

        // find object for this field (from last OBJECT line)
        if (type === '' || !types[type] || types[type].length < 1) {
            continue;
        }
        const obj = types[type][types[type].length - 1];

        if (key === 'DATA' || key === '') {
            // if DATA - start a new coordinate array in obj.crd
            if (key === 'DATA') {
                obj.crd.push([]);
            }
            if (obj.crd.length < 1) {
                continue;
            }
            const crds = obj.crd[obj.crd.length - 1];

            for (const p of val.split(' ')) {
                const crd = p.split(',');
                if (crd.length !== 2) {
                    continue;
                }
                const lat = parseInt(crd[1], 10) / 1e6;
                const lng = parseInt(crd[0], 10) / 1e6;
                crds.push({lat: lat, lng: lng});
            }
        }
        // if (key === 'LABEL') {
        // }
        // if (key === 'OPT') {
        // }
    }

    const ret = [];
    for (const tt of TypeTab) {
        if (!types[tt[0]] || tt[1] === 0) {
            continue;
        }

        const tnum = tt[0];
        const tcol = tt[2];
        const twgt = tt[3];
        const comm = tt[4];

        const cl = tnum >> 20;
        const scl = ['p:', 'l:', 'a:'][cl];
        let tname = scl + '0x' + (tnum & 0xffff).toString(16);
        if (comm) {
            tname = tname + ': ' + comm;
        }

        const trks = [];
        const wpts = [];

        for (const o of types[tnum]) {
            for (const c of o.crd) {
                if (cl === 0 && c.length > 0) {
                    const pt = c[0];
                    pt.name = o.name;
                    wpts.push(pt);
                }
                if (cl > 0) {
                    trks.push(c);
                }
            }
        }
        ret.push({name: tname, color: tcol, weight: twgt, tracks: trks, points: wpts, error: error});
    }
    return ret;
}

export default parseVMAP1;
